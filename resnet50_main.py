# -*- coding: utf-8 -*-
"""ResNet50.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16-5lZ6MZ3YvtTGLwVei-UvqtA2621NEr

**Data preprocessing and exploration**
"""

from google.colab import drive
drive.mount('/content/drive')

import os
import pandas as pd
import shutil
import matplotlib.pyplot as plt
import tensorflow as tf

data_dir = '/content/drive/MyDrive/Plant_Leaf_Disease_Dataset'
train_dir = '/content/drive/MyDrive/Plant_Leaf_Disease_Dataset/train'
valid_dir = '/content/drive/MyDrive/Plant_Leaf_Disease_Dataset/valid'

"""**Exploring the number of plants, diseases and each plant/disease image counts**"""

# Store all the train_dir sub directory names in folders list
folders = os.listdir(train_dir)
print(folders)

# Display per class image count

map = {}
for dir_name in folders:
  map[dir_name] = len(os.listdir(os.path.join(train_dir, dir_name)))

images_per_class = pd.DataFrame(map.values(), index = map.keys(), columns=["Number of Images"])
images_per_class

"""**Total images available for training**"""

n_train = 0
for val in map.values():
  n_train += val
print("Total available images for training: ", n_train)

"""**Data preparation**"""

train_arr = tf.keras.preprocessing.image_dataset_from_directory(
    train_dir,
    labels="inferred"
)
valid_arr = tf.keras.preprocessing.image_dataset_from_directory(
    valid_dir,
    labels="inferred"
)

# Change the calculation of num_rows to use integer division
num_rows = num_classes // 3

# Plot one image from each class
plt.figure(figsize=(10, 10))
for i, (class_name, image) in enumerate(class_images.items()):
    ax = plt.subplot(num_rows, 3, i + 1)
    plt.imshow(image)
    plt.title(class_name)
    plt.axis("off")

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

class_names = train_arr.class_names

# Create a dictionary to store one image per class
class_images = {}

# Iterate through the dataset to find one image per class
for images, labels in train_arr:
    for image, label in zip(images, labels):
        class_name = class_names[label.numpy()]
        if class_name not in class_images:
            class_images[class_name] = image.numpy().astype("uint8")
        if len(class_images) == 10:  # Stop when we have 10 classes
            break
    if len(class_images) == 10:  # Stop when we have 10 classes
        break

# Plot one image from each of the 10 classes in a 2x5 grid
plt.figure(figsize=(15, 6))  # Adjust the figure size as needed
num_classes = len(class_images.keys())
num_rows, num_cols = 2, 5

for i, (class_name, image) in enumerate(class_images.items()):
    ax = plt.subplot(num_rows, num_cols, i + 1)
    plt.imshow(image)
    plt.title(class_name)
    plt.axis("off")

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

class_names = train_arr.class_names

# Create a dictionary to store one image per class
class_images = {}

# Iterate through the dataset to find one image per class
for images, labels in train_arr:
    for image, label in zip(images, labels):
        class_name = class_names[label.numpy()]
        if class_name not in class_images:
            class_images[class_name] = image.numpy().astype("uint8")
            break

# Plot one image from each class
plt.figure(figsize=(10, 10))
num_classes = len(class_images.keys())
for i, (class_name, image) in enumerate(class_images.items()):
    ax = plt.subplot(np.ceil(num_classes // 3), 3, i + 1)
    plt.imshow(image)
    plt.title(class_name)
    plt.axis("off")

plt.tight_layout()
plt.show()

#Display some random images along with their classes
class_name = train_arr.class_names

plt.figure(figsize=(10, 10))
for images, labels in train_arr.take(1):
  for i in range(9):
    ax = plt.subplot(3, 3, i + 1)
    plt.imshow(images[i].numpy().astype("uint8"))
    plt.title(class_name[labels[i]])
    plt.axis("off")

#Dimensions of the images
for image_batch, labels_batch in train_arr:
  print(image_batch.shape)
  print(labels_batch.shape)
  break

#10 classes of images with each image of size 256 x 256 x 3

"""**ResNet 50**"""

data_dir = '/content/drive/MyDrive/Plant_Leaf_Disease_Dataset'
train_dir = '/content/drive/MyDrive/Plant_Leaf_Disease_Dataset/train'
valid_dir = '/content/drive/MyDrive/Plant_Leaf_Disease_Dataset/valid'
#test_dir = 'C:/Users/DELL/OneDrive/Documents/Folder1/FARMACY/FARMACY CODE/test_files'

#IMPORTING LIBRARIES
import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt

import tensorflow
from tensorflow import keras

from keras.models import Sequential,load_model,Model
from keras.layers import Conv2D,MaxPool2D,AveragePooling2D,Dense,Flatten,ZeroPadding2D,BatchNormalization,Activation,Add,Input,Dropout,GlobalAveragePooling2D
from keras.optimizers import SGD
from keras.initializers import glorot_uniform
from keras.preprocessing.image import ImageDataGenerator
from keras.callbacks import ModelCheckpoint,EarlyStopping,ReduceLROnPlateau

from tensorflow.keras.applications import ResNet50
from tensorflow.keras.applications.resnet50 import preprocess_input

base_model_tf=ResNet50(include_top=False,weights='imagenet',input_shape=(224,224,3),classes=10)

#Model building
base_model_tf.trainable=False

pt=Input(shape=(224,224,3))
func=tensorflow.cast(pt,tensorflow.float32)
x=preprocess_input(func) #This function used to zero-center each color channel wrt Imagenet dataset
model_resnet=base_model_tf(x,training=False)
model_resnet=GlobalAveragePooling2D()(model_resnet)
model_resnet=Dense(128,activation='relu')(model_resnet)
model_resnet=Dense(64,activation='relu')(model_resnet)
model_resnet=Dense(10,activation='softmax')(model_resnet)


model_main=Model(inputs=pt,outputs=model_resnet)
model_main.summary()

#Image augmentation
train_datagen= ImageDataGenerator(shear_range=0.2,zoom_range=0.2,horizontal_flip=False,vertical_flip=False
                                  ,fill_mode='nearest',width_shift_range=0.2,height_shift_range=0.2)

val_datagen=ImageDataGenerator()

train= train_datagen.flow_from_directory(directory=train_dir,batch_size=32,target_size=(224,224),
                                         color_mode='rgb',class_mode='categorical',seed=42)

valid=val_datagen.flow_from_directory(directory=valid_dir,batch_size=32,target_size=(224,224),color_mode='rgb',class_mode='categorical')

#CallBacks
es = EarlyStopping(monitor='val_accuracy',verbose=1,patience=7,mode='auto')
mc = ModelCheckpoint(filepath='/content/drive/MyDrive/Plant_Leaf_Disease_Dataset',monitor='val_accuracy',verbose=1,save_best_only=True)
lr = ReduceLROnPlateau(monitor='val_accuracy',verbose=1,patience=5,min_lr=0.001)

model_main.compile(optimizer='nadam',loss='categorical_crossentropy',metrics=['accuracy'])

#Training
model_main.fit(train,validation_data=valid,epochs=30,steps_per_epoch=200,verbose=1,callbacks=[mc,es,lr])

model_main.save("RESNET50_PLANT_DISEASE_1.h5")

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline

import cv2
from PIL import Image

plt.figure(figsize=(10,5))
plt.plot(model_main.history.history['loss'],color='b',label='Training loss')
plt.plot(model_main.history.history['val_loss'],color='r',label='Validation loss')
plt.xlabel("epochs")
plt.ylabel("loss_value")
plt.legend(['training', 'validation'])
plt.title("Loss Graph")

#text(0.5, 1.0, 'loss')

plt.figure(figsize=(10,5))
plt.plot(model_main.history.history['accuracy'],color='b',label='Training accuracy')
plt.plot(model_main.history.history['val_accuracy'],color='r',label='Validation accuracy')
plt.xlabel("epochs")
plt.ylabel("accuracy")
plt.legend(['training', 'validation'])
plt.title("Accuracy Graph")

#Text(0.5, 1.0, 'accuracy graph')